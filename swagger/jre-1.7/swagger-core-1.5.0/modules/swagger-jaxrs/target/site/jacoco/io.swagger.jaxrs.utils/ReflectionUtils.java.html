<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReflectionUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swagger-jaxrs</a> &gt; <a href="index.source.html" class="el_package">io.swagger.jaxrs.utils</a> &gt; <span class="el_source">ReflectionUtils.java</span></div><h1>ReflectionUtils.java</h1><pre class="source lang-java linenums">package io.swagger.jaxrs.utils;

import com.google.common.base.Function;
import com.google.common.collect.Collections2;

import javax.ws.rs.HeaderParam;
import javax.ws.rs.PathParam;
import javax.ws.rs.QueryParam;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

<span class="nc" id="L20">public class ReflectionUtils {</span>

    private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; CONSTRUCTOR_ANNOTATIONS;

    /**
     * Checks if the method methodToFind is the overridden method from the superclass.
     *
     * @param methodToFind is method to check
     * @param cls          is method class
     * @return true if the method is overridden method
     */
    public static boolean isOverriddenMethod(Method methodToFind, Class&lt;?&gt; cls) {
<span class="fc" id="L32">        Class&lt;?&gt; superClass = cls.getSuperclass();</span>
<span class="pc bpc" id="L33" title="1 of 4 branches missed.">        if (superClass != null &amp;&amp; !(superClass.getClass().equals(Object.class))) {</span>
<span class="fc bfc" id="L34" title="All 2 branches covered.">            for (Method method : superClass.getMethods()) {</span>
<span class="pc bpc" id="L35" title="1 of 4 branches missed.">                if (!method.getName().equals(methodToFind.getName()) || !method.getReturnType().isAssignableFrom(methodToFind.getReturnType())) {</span>
<span class="nc" id="L36">                    continue;</span>
                }
<span class="fc bfc" id="L38" title="All 4 branches covered.">                if (Arrays.equals(method.getParameterTypes(), methodToFind.getParameterTypes()) &amp;&amp;</span>
                        !Arrays.equals(method.getGenericParameterTypes(), methodToFind.getGenericParameterTypes())) {
<span class="fc" id="L40">                    return true;</span>
                }
            }
<span class="fc" id="L43">            return isOverriddenMethod(methodToFind, superClass);</span>
        }
<span class="fc" id="L45">        return false;</span>
    }

    /**
     * Returns overridden method from superclass if it exists. If method was not found returns null.
     *
     * @param method is method to find
     * @return overridden method from superclass
     */
    public static Method getOverriddenMethod(Method method) {
<span class="fc" id="L55">        Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span>
<span class="fc" id="L56">        Class&lt;?&gt; superClass = declaringClass.getSuperclass();</span>
<span class="pc bpc" id="L57" title="1 of 4 branches missed.">        if (superClass != null &amp;&amp; !(superClass.getClass().equals(Object.class))) {</span>
<span class="fc" id="L58">            Method result = findMethod(method, superClass);</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">            if (result == null) {</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">                for (Class&lt;?&gt; anInterface : declaringClass.getInterfaces()) {</span>
<span class="fc" id="L61">                    result = findMethod(method, anInterface);</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">                    if (result != null) {</span>
<span class="fc" id="L63">                        return result;</span>
                    }
                }
            } else {
<span class="fc" id="L67">                return result;</span>
            }
        }
<span class="fc" id="L70">        return null;</span>
    }

    /**
     * Searches the method methodToFind in given class cls. If the method is found returns it, else return null.
     *
     * @param methodToFind is the method to search
     * @param cls          is the class or interface where to search
     * @return method if it is found
     */
    public static Method findMethod(Method methodToFind, Class&lt;?&gt; cls) {
<span class="fc" id="L81">        String methodToSearch = methodToFind.getName();</span>
<span class="fc" id="L82">        Class&lt;?&gt;[] pTypes = methodToFind.getParameterTypes();</span>
<span class="fc" id="L83">        Type[] gpTypes = methodToFind.getGenericParameterTypes();</span>
        methodLoop:
<span class="fc bfc" id="L85" title="All 2 branches covered.">        for (Method method : cls.getMethods()) {</span>
<span class="pc bpc" id="L86" title="1 of 4 branches missed.">            if (!method.getName().equals(methodToSearch) || !method.getReturnType().isAssignableFrom(methodToFind.getReturnType())) {</span>
<span class="nc" id="L87">                continue;</span>
            }
<span class="fc" id="L89">            Class&lt;?&gt;[] pt = method.getParameterTypes();</span>
<span class="fc" id="L90">            Type[] gpt = method.getGenericParameterTypes();</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">            for (int j = 0; j &lt; pTypes.length; j++) {</span>
<span class="fc" id="L92">                Class&lt;?&gt; parameterType = pTypes[j];</span>
<span class="pc bpc" id="L93" title="2 of 6 branches missed.">                if (!(pt[j].equals(parameterType) || (!gpt[j].equals(gpTypes[j]) &amp;&amp; pt[j].isAssignableFrom(parameterType)))) {</span>
<span class="nc" id="L94">                    continue methodLoop;</span>
                }
            }
<span class="fc" id="L97">            return method;</span>
        }
<span class="fc" id="L99">        return null;</span>
    }

    /**
     * Searches for constructor suitable for resource instantiation.
     * &lt;p/&gt;
     * If more constructors exists the one with the most injectable parameters will be selected.
     *
     * @param cls is the class where to search
     * @return the suitable constructor
     */
    public static Constructor&lt;?&gt; findConstructor(Class&lt;?&gt; cls) {
<span class="pc bpc" id="L111" title="2 of 6 branches missed.">        if (cls.isLocalClass() || (cls.isMemberClass() &amp;&amp; !Modifier.isStatic(cls.getModifiers()))) {</span>
<span class="nc" id="L112">            return null;</span>
        }

<span class="fc" id="L115">        Constructor&lt;?&gt; selected = null;</span>
<span class="fc" id="L116">        int selectedCount = 0;</span>
<span class="fc" id="L117">        int maxParams = -1;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (Constructor&lt;?&gt; constructor : cls.getDeclaredConstructors()) {</span>
<span class="fc" id="L119">            final Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();</span>
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">            if (parameterTypes.length &gt;= maxParams &amp;&amp; isCompatible(constructor)) {</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">                if (parameterTypes.length &gt; maxParams) {</span>
<span class="fc" id="L122">                    maxParams = parameterTypes.length;</span>
<span class="fc" id="L123">                    selectedCount = 0;</span>
                }

<span class="fc" id="L126">                selected = constructor;</span>
<span class="fc" id="L127">                selectedCount++;</span>
            }
        }

<span class="fc bfc" id="L131" title="All 2 branches covered.">        return selectedCount == 1 ? selected : null;</span>
    }

    /**
     * Returns an implementation of {@link Function} for getting annotation types.
     *
     * @return the implementation of {@link Function} for getting annotation types
     */
    public static Function&lt;Annotation, Class&lt;? extends Annotation&gt;&gt; createAnnotationTypeGetter() {
<span class="fc" id="L140">        return new Function&lt;Annotation, Class&lt;? extends Annotation&gt;&gt;() {</span>
            @Override
            public Class&lt;? extends Annotation&gt; apply(Annotation annotation) {
<span class="fc" id="L143">                return annotation.annotationType();</span>
            }
        };
    }

    /**
     * Checks if the passed constructor is suitable for resource instantiation.
     * Repeats the logic of the {@link org.glassfish.jersey.internal.inject.JerseyClassAnalyzer#isCompatible(java.lang.reflect.Constructor)}
     *
     * @param constructor the constructor to be checked
     * @return true if the constructor is suitable or false otherwise
     */
    private static boolean isCompatible(Constructor&lt;?&gt; constructor) {
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        for (Annotation annotation : constructor.getAnnotations()) {</span>
            // use string name to avoid additional dependencies
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (&quot;javax.inject.Inject&quot;.equals(annotation.annotationType().getName())) {</span>
<span class="nc" id="L159">                return true;</span>
            }
        }

<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (!Modifier.isPublic(constructor.getModifiers())) {</span>
<span class="nc" id="L164">            final int access = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">            return constructor.getParameterTypes().length == 0 &amp;&amp;</span>
                    (constructor.getDeclaringClass().getModifiers() &amp; access) == constructor.getModifiers();
        }

<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (Annotation[] paramAnnotations : constructor.getParameterAnnotations()) {</span>
<span class="fc" id="L170">            final Collection&lt;Class&lt;? extends Annotation&gt;&gt; tmp = Collections2.transform(Arrays.asList(paramAnnotations),</span>
                    ReflectionUtils.createAnnotationTypeGetter());
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (Collections.disjoint(tmp, CONSTRUCTOR_ANNOTATIONS)) {</span>
<span class="fc" id="L173">                return false;</span>
            }
        }

<span class="fc" id="L177">        return true;</span>
    }

    static {
<span class="fc" id="L181">        final Set&lt;Class&lt;? extends Annotation&gt;&gt; constructorAnnotations = new HashSet&lt;Class&lt;? extends Annotation&gt;&gt;();</span>
<span class="fc" id="L182">        constructorAnnotations.add(PathParam.class);</span>
<span class="fc" id="L183">        constructorAnnotations.add(QueryParam.class);</span>
<span class="fc" id="L184">        constructorAnnotations.add(HeaderParam.class);</span>
<span class="fc" id="L185">        CONSTRUCTOR_ANNOTATIONS = Collections.unmodifiableSet(constructorAnnotations);</span>
<span class="fc" id="L186">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>