<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Reader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">swagger-jaxrs</a> &gt; <a href="index.source.html" class="el_package">io.swagger.jaxrs</a> &gt; <span class="el_source">Reader.java</span></div><h1>Reader.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2015 SmartBear Software
 * &lt;p/&gt;
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * &lt;p/&gt;
 * http://www.apache.org/licenses/LICENSE-2.0
 * &lt;p/&gt;
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.swagger.jaxrs;

import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.google.common.collect.Collections2;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import io.swagger.annotations.ApiResponse;
import io.swagger.annotations.ApiResponses;
import io.swagger.annotations.Authorization;
import io.swagger.annotations.AuthorizationScope;
import io.swagger.annotations.Extension;
import io.swagger.annotations.ExtensionProperty;
import io.swagger.annotations.Info;
import io.swagger.annotations.ResponseHeader;
import io.swagger.annotations.SwaggerDefinition;
import io.swagger.converter.ModelConverters;
import io.swagger.jaxrs.config.DefaultReaderConfig;
import io.swagger.jaxrs.config.ReaderConfig;
import io.swagger.jaxrs.config.ReaderListener;
import io.swagger.jaxrs.ext.SwaggerExtension;
import io.swagger.jaxrs.ext.SwaggerExtensions;
import io.swagger.jaxrs.utils.ReflectionUtils;
import io.swagger.models.Contact;
import io.swagger.models.ExternalDocs;
import io.swagger.models.License;
import io.swagger.models.Model;
import io.swagger.models.Operation;
import io.swagger.models.Path;
import io.swagger.models.Response;
import io.swagger.models.Scheme;
import io.swagger.models.SecurityRequirement;
import io.swagger.models.SecurityScope;
import io.swagger.models.Swagger;
import io.swagger.models.Tag;
import io.swagger.models.parameters.BodyParameter;
import io.swagger.models.parameters.FormParameter;
import io.swagger.models.parameters.HeaderParameter;
import io.swagger.models.parameters.Parameter;
import io.swagger.models.parameters.PathParameter;
import io.swagger.models.parameters.QueryParameter;
import io.swagger.models.properties.ArrayProperty;
import io.swagger.models.properties.MapProperty;
import io.swagger.models.properties.Property;
import io.swagger.models.properties.RefProperty;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.ws.rs.Consumes;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.HttpMethod;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Reader {
<span class="fc" id="L95">    private static final Logger LOGGER = LoggerFactory.getLogger(Reader.class);</span>
    private static final String SUCCESSFUL_OPERATION = &quot;successful operation&quot;;
    private static final String PATH_DELIMITER = &quot;/&quot;;

    private static final Set&lt;Class&lt;? extends Annotation&gt;&gt; FIELD_ANNOTATIONS;
    private final ReaderConfig config;
    private Swagger swagger;



    public Reader(Swagger swagger) {
<span class="fc" id="L106">        this(swagger, null);</span>
<span class="fc" id="L107">    }</span>

<span class="fc" id="L109">    public Reader(Swagger swagger, ReaderConfig config) {</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        this.swagger = swagger == null ? new Swagger() : swagger;</span>
<span class="fc" id="L111">        this.config = new DefaultReaderConfig(config);</span>
<span class="fc" id="L112">    }</span>

    /**
     * Scans a set of classes for both ReaderListeners and Swagger annotations. All found listeners will
     * be instantiated before any of the classes are scanned for Swagger annotations - so they can be invoked
     * accordingly.
     *
     * @param classes a set of classes to scan
     * @return the generated Swagger definition
     */

    public Swagger read(Set&lt;Class&lt;?&gt;&gt; classes) {

<span class="fc" id="L125">        Map&lt;Class&lt;?&gt;, ReaderListener&gt; listeners = new HashMap&lt;Class&lt;?&gt;, ReaderListener&gt;();</span>

<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (Class&lt;?&gt; cls : classes) {</span>
<span class="pc bpc" id="L128" title="1 of 4 branches missed.">            if (ReaderListener.class.isAssignableFrom(cls) &amp;&amp; !listeners.containsKey(cls)) {</span>
                try {
<span class="fc" id="L130">                    listeners.put(cls, (ReaderListener) cls.newInstance());</span>
<span class="nc" id="L131">                } catch (Exception e) {</span>
<span class="nc" id="L132">                    LOGGER.error(&quot;Failed to create ReaderListener&quot;, e);</span>
<span class="fc" id="L133">                }</span>
            }
<span class="fc" id="L135">        }</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">        for (ReaderListener listener : listeners.values()) {</span>
            try {
<span class="fc" id="L139">                listener.beforeScan(this, swagger);</span>
<span class="nc" id="L140">            } catch (Exception e) {</span>
<span class="nc" id="L141">                LOGGER.error(&quot;Unexpected error invoking beforeScan listener [&quot; + listener.getClass().getName() + &quot;]&quot;, e);</span>
<span class="fc" id="L142">            }</span>
<span class="fc" id="L143">        }</span>

<span class="fc bfc" id="L145" title="All 2 branches covered.">        for (Class&lt;?&gt; cls : classes) {</span>
<span class="fc" id="L146">            read(cls);</span>
<span class="fc" id="L147">        }</span>

<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (ReaderListener listener : listeners.values()) {</span>
            try {
<span class="fc" id="L151">                listener.afterScan(this, swagger);</span>
<span class="nc" id="L152">            } catch (Exception e) {</span>
<span class="nc" id="L153">                LOGGER.error(&quot;Unexpected error invoking afterScan listener [&quot; + listener.getClass().getName() + &quot;]&quot;, e);</span>
<span class="fc" id="L154">            }</span>
<span class="fc" id="L155">        }</span>

<span class="fc" id="L157">        return swagger;</span>
    }

    public Swagger getSwagger() {
<span class="fc" id="L161">        return this.swagger;</span>
    }

    /**
     * Scans a single class for Swagger annotations - does not invoke ReaderListeners
     */

    public Swagger read(Class&lt;?&gt; cls) {
<span class="fc" id="L169">        return read(cls, &quot;&quot;, null, false, new String[0], new String[0], new HashMap&lt;String, Tag&gt;(), new ArrayList&lt;Parameter&gt;());</span>
    }

    protected Swagger read(Class&lt;?&gt; cls, String parentPath, String parentMethod, boolean readHidden, String[] parentConsumes, String[] parentProduces, Map&lt;String, Tag&gt; parentTags, List&lt;Parameter&gt; parentParameters) {
<span class="fc" id="L173">        SwaggerDefinition swaggerDefinition = cls.getAnnotation(SwaggerDefinition.class);</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">        if (swaggerDefinition != null) {</span>
<span class="fc" id="L175">            readSwaggerConfig(cls, swaggerDefinition);</span>
        }

<span class="fc" id="L178">        Api api = (Api) cls.getAnnotation(Api.class);</span>
<span class="fc" id="L179">        Map&lt;String, SecurityScope&gt; globalScopes = new HashMap&lt;String, SecurityScope&gt;();</span>

<span class="fc" id="L181">        Map&lt;String, Tag&gt; tags = new HashMap&lt;String, Tag&gt;();</span>
<span class="fc" id="L182">        List&lt;SecurityRequirement&gt; securities = new ArrayList&lt;SecurityRequirement&gt;();</span>

<span class="fc" id="L184">        String[] consumes = new String[0];</span>
<span class="fc" id="L185">        String[] produces = new String[0];</span>
<span class="fc" id="L186">        final Set&lt;Scheme&gt; globalSchemes = EnumSet.noneOf(Scheme.class);</span>

        // only read if allowing hidden apis OR api is not marked as hidden
<span class="fc bfc" id="L189" title="All 8 branches covered.">        final boolean readable = (api != null &amp;&amp; readHidden) || (api != null &amp;&amp; !api.hidden());</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (readable) {</span>
            // the value will be used as a tag for 2.0 UNLESS a Tags annotation is present
<span class="fc" id="L192">            Set&lt;String&gt; tagStrings = extractTags(api);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">            for (String tagString : tagStrings) {</span>
<span class="fc" id="L194">                Tag tag = new Tag().name(tagString);</span>
<span class="fc" id="L195">                tags.put(tagString, tag);</span>
<span class="fc" id="L196">            }</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            if (parentTags != null) {</span>
<span class="fc" id="L198">                tags.putAll(parentTags);</span>
            }
<span class="fc bfc" id="L200" title="All 2 branches covered.">            for (String tagName : tags.keySet()) {</span>
<span class="fc" id="L201">                swagger.tag(tags.get(tagName));</span>
<span class="fc" id="L202">            }</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">            if (!api.produces().isEmpty()) {</span>
<span class="fc" id="L205">                produces = new String[]{api.produces()};</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">            } else if (cls.getAnnotation(Produces.class) != null) {</span>
<span class="fc" id="L207">                produces = ((Produces) cls.getAnnotation(Produces.class)).value();</span>
            }
<span class="fc bfc" id="L209" title="All 2 branches covered.">            if (!api.consumes().isEmpty()) {</span>
<span class="fc" id="L210">                consumes = new String[]{api.consumes()};</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">            } else if (cls.getAnnotation(Consumes.class) != null) {</span>
<span class="fc" id="L212">                consumes = ((Consumes) cls.getAnnotation(Consumes.class)).value();</span>
            }
<span class="fc" id="L214">            globalSchemes.addAll(parseSchemes(api.protocols()));</span>
<span class="fc" id="L215">            Authorization[] authorizations = api.authorizations();</span>

<span class="fc bfc" id="L217" title="All 2 branches covered.">            for (Authorization auth : authorizations) {</span>
<span class="pc bpc" id="L218" title="1 of 4 branches missed.">                if (auth.value() != null &amp;&amp; !&quot;&quot;.equals(auth.value())) {</span>
<span class="fc" id="L219">                    SecurityRequirement security = new SecurityRequirement();</span>
<span class="fc" id="L220">                    security.setName(auth.value());</span>
<span class="fc" id="L221">                    AuthorizationScope[] scopes = auth.scopes();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">                    for (AuthorizationScope scope : scopes) {</span>
<span class="pc bpc" id="L223" title="1 of 4 branches missed.">                        if (scope.scope() != null &amp;&amp; !&quot;&quot;.equals(scope.scope())) {</span>
<span class="fc" id="L224">                            security.addScope(scope.scope());</span>
                        }
                    }
<span class="fc" id="L227">                    securities.add(security);</span>
                }
            }
        }

        // allow reading the JAX-RS APIs without @Api annotation
<span class="fc bfc" id="L233" title="All 6 branches covered.">        if (readable || (api == null &amp;&amp; config.isScanAllResources())) {</span>
            // merge consumes, produces

            // look for method-level annotated properties

            // handle sub-resources by looking at return type

            // parse the method
<span class="fc" id="L241">            final javax.ws.rs.Path apiPath = cls.getAnnotation(javax.ws.rs.Path.class);</span>
<span class="fc" id="L242">            Method methods[] = cls.getMethods();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            for (Method method : methods) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">                if (ReflectionUtils.isOverriddenMethod(method, cls)) {</span>
<span class="fc" id="L245">                    continue;</span>
                }
<span class="fc" id="L247">                javax.ws.rs.Path methodPath = getAnnotation(method, javax.ws.rs.Path.class);</span>

<span class="fc" id="L249">                String operationPath = getPath(apiPath, methodPath, parentPath);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">                if (operationPath != null) {</span>
<span class="fc" id="L251">                    String[] pps = operationPath.split(&quot;/&quot;);</span>
<span class="fc" id="L252">                    String[] pathParts = new String[pps.length];</span>
<span class="fc" id="L253">                    Map&lt;String, String&gt; regexMap = new HashMap&lt;String, String&gt;();</span>

<span class="fc bfc" id="L255" title="All 2 branches covered.">                    for (int i = 0; i &lt; pps.length; i++) {</span>
<span class="fc" id="L256">                        String p = pps[i];</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">                        if (p.startsWith(&quot;{&quot;)) {</span>
<span class="fc" id="L258">                            int pos = p.indexOf(&quot;:&quot;);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">                            if (pos &gt; 0) {</span>
<span class="fc" id="L260">                                String left = p.substring(1, pos);</span>
<span class="fc" id="L261">                                String right = p.substring(pos + 1, p.length() - 1);</span>
<span class="fc" id="L262">                                pathParts[i] = &quot;{&quot; + left + &quot;}&quot;;</span>
<span class="fc" id="L263">                                regexMap.put(left, right);</span>
<span class="fc" id="L264">                            } else {</span>
<span class="fc" id="L265">                                pathParts[i] = p;</span>
                            }
<span class="fc" id="L267">                        } else {</span>
<span class="fc" id="L268">                            pathParts[i] = p;</span>
                        }
                    }
<span class="fc" id="L271">                    StringBuilder pathBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                    for (String p : pathParts) {</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                        if (!p.isEmpty()) {</span>
<span class="fc" id="L274">                            pathBuilder.append(&quot;/&quot;).append(p);</span>
                        }
                    }
<span class="fc" id="L277">                    operationPath = pathBuilder.toString();</span>

<span class="pc bpc" id="L279" title="1 of 2 branches missed.">                    if (isIgnored(operationPath)) {</span>
<span class="nc" id="L280">                        continue;</span>
                    }

<span class="fc" id="L283">                    final ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);</span>
<span class="fc" id="L284">                    String httpMethod = extractOperationMethod(apiOperation, method, SwaggerExtensions.chain());</span>

<span class="fc" id="L286">                    Operation operation = parseMethod(method, collectGlobalParameters(cls));</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">                    if (operation == null) {</span>
<span class="fc" id="L288">                        continue;</span>
                    }
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                    if (parentParameters != null) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                        for (Parameter param : parentParameters) {</span>
<span class="fc" id="L292">                            operation.parameter(param);</span>
<span class="fc" id="L293">                        }</span>
                    }
<span class="fc bfc" id="L295" title="All 2 branches covered.">                    for (Parameter param : operation.getParameters()) {</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                        if (regexMap.get(param.getName()) != null) {</span>
<span class="fc" id="L297">                            String pattern = regexMap.get(param.getName());</span>
<span class="fc" id="L298">                            param.setPattern(pattern);</span>
                        }
<span class="fc" id="L300">                    }</span>

<span class="fc bfc" id="L302" title="All 2 branches covered.">                    if (apiOperation != null) {</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                        for (Scheme scheme : parseSchemes(apiOperation.protocols())) {</span>
<span class="fc" id="L304">                            operation.scheme(scheme);</span>
<span class="fc" id="L305">                        }</span>
                    }

<span class="pc bpc" id="L308" title="1 of 4 branches missed.">                    if (operation.getSchemes() == null || operation.getSchemes().isEmpty()) {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                        for (Scheme scheme : globalSchemes) {</span>
<span class="fc" id="L310">                            operation.scheme(scheme);</span>
<span class="fc" id="L311">                        }</span>
                    }

<span class="fc" id="L314">                    String[] apiConsumes = consumes;</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                    if (parentConsumes != null) {</span>
<span class="fc" id="L316">                        Set&lt;String&gt; both = new HashSet&lt;String&gt;(Arrays.asList(apiConsumes));</span>
<span class="fc" id="L317">                        both.addAll(new HashSet&lt;String&gt;(Arrays.asList(parentConsumes)));</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                        if (operation.getConsumes() != null) {</span>
<span class="fc" id="L319">                            both.addAll(new HashSet&lt;String&gt;(operation.getConsumes()));</span>
                        }
<span class="fc" id="L321">                        apiConsumes = both.toArray(new String[both.size()]);</span>
                    }

<span class="fc" id="L324">                    String[] apiProduces = produces;</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">                    if (parentProduces != null) {</span>
<span class="fc" id="L326">                        Set&lt;String&gt; both = new HashSet&lt;String&gt;(Arrays.asList(apiProduces));</span>
<span class="fc" id="L327">                        both.addAll(new HashSet&lt;String&gt;(Arrays.asList(parentProduces)));</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">                        if (operation.getProduces() != null) {</span>
<span class="fc" id="L329">                            both.addAll(new HashSet&lt;String&gt;(operation.getProduces()));</span>
                        }
<span class="fc" id="L331">                        apiProduces = both.toArray(new String[both.size()]);</span>
                    }
<span class="fc" id="L333">                    final Class&lt;?&gt; subResource = getSubResource(method);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                    if (subResource != null) {</span>
<span class="fc" id="L335">                        read(subResource, operationPath, httpMethod, true, apiConsumes, apiProduces, tags, operation.getParameters());</span>
                    }

                    // can't continue without a valid http method
<span class="fc bfc" id="L339" title="All 2 branches covered.">                    httpMethod = httpMethod == null ? parentMethod : httpMethod;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                    if (httpMethod != null) {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">                        if (apiOperation != null) {</span>
<span class="fc" id="L342">                            boolean hasExplicitTag = false;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">                            for (String tag : apiOperation.tags()) {</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">                                if (!&quot;&quot;.equals(tag)) {</span>
<span class="fc" id="L345">                                    operation.tag(tag);</span>
<span class="fc" id="L346">                                    swagger.tag(new Tag().name(tag));</span>
                                }
                            }

<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                            if (operation != null) {</span>
<span class="fc" id="L351">                                addExtensionProperties(apiOperation.extensions(), operation.getVendorExtensions());</span>
                            }
                        }
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">                        if (operation != null) {</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">                            if (operation.getConsumes() == null) {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                                for (String mediaType : apiConsumes) {</span>
<span class="fc" id="L357">                                    operation.consumes(mediaType);</span>
                                }
                            }
<span class="fc bfc" id="L360" title="All 2 branches covered.">                            if (operation.getProduces() == null) {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                                for (String mediaType : apiProduces) {</span>
<span class="fc" id="L362">                                    operation.produces(mediaType);</span>
                                }
                            }

<span class="fc bfc" id="L366" title="All 2 branches covered.">                            if (operation.getTags() == null) {</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">                                for (String tagString : tags.keySet()) {</span>
<span class="fc" id="L368">                                    operation.tag(tagString);</span>
<span class="fc" id="L369">                                }</span>
                            }
                            // Only add global @Api securities if operation doesn't already have more specific securities
<span class="fc bfc" id="L372" title="All 2 branches covered.">                            if (operation.getSecurity() == null) {</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">                                for (SecurityRequirement security : securities) {</span>
<span class="fc" id="L374">                                    operation.security(security);</span>
<span class="fc" id="L375">                                }</span>
                            }

<span class="fc" id="L378">                            Path path = swagger.getPath(operationPath);</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">                            if (path == null) {</span>
<span class="fc" id="L380">                                path = new Path();</span>
<span class="fc" id="L381">                                swagger.path(operationPath, path);</span>
                            }
<span class="fc" id="L383">                            path.set(httpMethod, operation);</span>

<span class="fc" id="L385">                            readImplicitParameters(method, operation);</span>
                        }
                    }
                }
            }
        }

<span class="fc" id="L392">        return swagger;</span>
    }

    private void readImplicitParameters(Method method, Operation operation) {
<span class="fc" id="L396">        ApiImplicitParams implicitParams = method.getAnnotation(ApiImplicitParams.class);</span>
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">        if (implicitParams != null &amp;&amp; implicitParams.value().length &gt; 0) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">            for (ApiImplicitParam param : implicitParams.value()) {</span>
<span class="fc" id="L399">                Parameter p = readImplicitParam(param, method.getDeclaringClass());</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">                if (p != null) {</span>
<span class="fc" id="L401">                    operation.addParameter(p);</span>
                }
            }
        }
<span class="fc" id="L405">    }</span>

    protected Parameter readImplicitParam(ApiImplicitParam param, Class&lt;?&gt; apiClass) {
        Parameter p;
<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (param.paramType().equalsIgnoreCase(&quot;path&quot;)) {</span>
<span class="fc" id="L410">            p = new PathParameter();</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        } else if (param.paramType().equalsIgnoreCase(&quot;query&quot;)) {</span>
<span class="fc" id="L412">            p = new QueryParameter();</span>
<span class="fc bfc" id="L413" title="All 4 branches covered.">        } else if (param.paramType().equalsIgnoreCase(&quot;form&quot;) || param.paramType().equalsIgnoreCase(&quot;formData&quot;)) {</span>
<span class="fc" id="L414">            p = new FormParameter();</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        } else if (param.paramType().equalsIgnoreCase(&quot;body&quot;)) {</span>
<span class="fc" id="L416">            p = new BodyParameter();</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        } else if (param.paramType().equalsIgnoreCase(&quot;header&quot;)) {</span>
<span class="fc" id="L418">            p = new HeaderParameter();</span>
        } else {
<span class="fc" id="L420">            LOGGER.warn(&quot;Unkown implicit parameter type: [&quot; + param.paramType() + &quot;]&quot;);</span>
<span class="fc" id="L421">            return null;</span>
        }

<span class="fc" id="L424">        return ParameterProcessor.applyAnnotations(swagger, p, apiClass, Arrays.asList(new Annotation[]{param}));</span>
    }

    protected void readSwaggerConfig(Class&lt;?&gt; cls, SwaggerDefinition config) {

<span class="pc bpc" id="L429" title="1 of 2 branches missed.">        if (!config.basePath().isEmpty()) {</span>
<span class="nc" id="L430">            swagger.setBasePath(config.basePath());</span>
        }

<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        if (!config.host().isEmpty()) {</span>
<span class="nc" id="L434">            swagger.setHost(config.host());</span>
        }

<span class="fc" id="L437">        readInfoConfig(config);</span>

<span class="fc bfc" id="L439" title="All 2 branches covered.">        for (String consume : config.consumes()) {</span>
<span class="fc" id="L440">            swagger.addConsumes(consume);</span>
        }

<span class="fc bfc" id="L443" title="All 2 branches covered.">        for (String produce : config.produces()) {</span>
<span class="fc" id="L444">            swagger.addProduces(produce);</span>
        }

<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (!config.externalDocs().value().isEmpty()) {</span>
<span class="fc" id="L448">            ExternalDocs externalDocs = swagger.getExternalDocs();</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">            if (externalDocs == null) {</span>
<span class="fc" id="L450">                externalDocs = new ExternalDocs();</span>
<span class="fc" id="L451">                swagger.setExternalDocs(externalDocs);</span>
            }

<span class="fc" id="L454">            externalDocs.setDescription(config.externalDocs().value());</span>

<span class="pc bpc" id="L456" title="1 of 2 branches missed.">            if (!config.externalDocs().url().isEmpty()) {</span>
<span class="fc" id="L457">                externalDocs.setUrl(config.externalDocs().url());</span>
            }
        }

<span class="fc bfc" id="L461" title="All 2 branches covered.">        for (io.swagger.annotations.Tag tagConfig : config.tags()) {</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">            if (!tagConfig.name().isEmpty()) {</span>
<span class="fc" id="L463">                Tag tag = new Tag();</span>
<span class="fc" id="L464">                tag.setName(tagConfig.name());</span>
<span class="fc" id="L465">                tag.setDescription(tagConfig.description());</span>

<span class="fc bfc" id="L467" title="All 2 branches covered.">                if (!tagConfig.externalDocs().value().isEmpty()) {</span>
<span class="fc" id="L468">                    tag.setExternalDocs(new ExternalDocs(tagConfig.externalDocs().value(),</span>
                            tagConfig.externalDocs().url()));
                }

<span class="fc" id="L472">                addExtensionProperties(tagConfig.extensions(), tag.getVendorExtensions());</span>

<span class="fc" id="L474">                swagger.addTag(tag);</span>
            }
        }

<span class="fc bfc" id="L478" title="All 2 branches covered.">        for (SwaggerDefinition.Scheme scheme : config.schemes()) {</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">            if (scheme != SwaggerDefinition.Scheme.DEFAULT) {</span>
<span class="fc" id="L480">                swagger.addScheme(Scheme.forValue(scheme.name()));</span>
            }
        }
<span class="fc" id="L483">    }</span>

    protected void readInfoConfig(SwaggerDefinition config) {
<span class="fc" id="L486">        Info infoConfig = config.info();</span>
<span class="fc" id="L487">        io.swagger.models.Info info = swagger.getInfo();</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">        if (info == null) {</span>
<span class="fc" id="L489">            info = new io.swagger.models.Info();</span>
<span class="fc" id="L490">            swagger.setInfo(info);</span>
        }

<span class="pc bpc" id="L493" title="1 of 2 branches missed.">        if (!infoConfig.description().isEmpty()) {</span>
<span class="fc" id="L494">            info.setDescription(infoConfig.description());</span>
        }

<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if (!infoConfig.termsOfService().isEmpty()) {</span>
<span class="fc" id="L498">            info.setTermsOfService(infoConfig.termsOfService());</span>
        }

<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (!infoConfig.title().isEmpty()) {</span>
<span class="fc" id="L502">            info.setTitle(infoConfig.title());</span>
        }

<span class="pc bpc" id="L505" title="1 of 2 branches missed.">        if (!infoConfig.version().isEmpty()) {</span>
<span class="fc" id="L506">            info.setVersion(infoConfig.version());</span>
        }

<span class="pc bpc" id="L509" title="1 of 2 branches missed.">        if (!infoConfig.contact().name().isEmpty()) {</span>
<span class="fc" id="L510">            Contact contact = info.getContact();</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">            if (contact == null) {</span>
<span class="fc" id="L512">                contact = new Contact();</span>
<span class="fc" id="L513">                info.setContact(contact);</span>
            }

<span class="fc" id="L516">            contact.setName(infoConfig.contact().name());</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">            if (!infoConfig.contact().email().isEmpty()) {</span>
<span class="fc" id="L518">                contact.setEmail(infoConfig.contact().email());</span>
            }

<span class="pc bpc" id="L521" title="1 of 2 branches missed.">            if (!infoConfig.contact().url().isEmpty()) {</span>
<span class="fc" id="L522">                contact.setUrl(infoConfig.contact().url());</span>
            }
        }

<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (!infoConfig.license().name().isEmpty()) {</span>
<span class="fc" id="L527">            License license = info.getLicense();</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">            if (license == null) {</span>
<span class="fc" id="L529">                license = new License();</span>
<span class="fc" id="L530">                info.setLicense(license);</span>
            }

<span class="fc" id="L533">            license.setName(infoConfig.license().name());</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">            if (!infoConfig.license().url().isEmpty()) {</span>
<span class="fc" id="L535">                license.setUrl(infoConfig.license().url());</span>
            }
        }

<span class="fc" id="L539">        addExtensionProperties(infoConfig.extensions(), info.getVendorExtensions());</span>
<span class="fc" id="L540">    }</span>

    private void addExtensionProperties(Extension[] extensions, Map&lt;String, Object&gt; map) {
<span class="fc bfc" id="L543" title="All 2 branches covered.">        for (Extension extension : extensions) {</span>
<span class="fc" id="L544">            String name = extension.name();</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">            if (name.length() &gt; 0) {</span>

<span class="pc bpc" id="L547" title="1 of 2 branches missed.">                if (!name.startsWith(&quot;x-&quot;)) {</span>
<span class="fc" id="L548">                    name = &quot;x-&quot; + name;</span>
                }

<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                if (!map.containsKey(name)) {</span>
<span class="fc" id="L552">                    map.put(name, new HashMap&lt;String, Object&gt;());</span>
                }

<span class="fc" id="L555">                map = (Map&lt;String, Object&gt;) map.get(name);</span>
            }

<span class="fc bfc" id="L558" title="All 2 branches covered.">            for (ExtensionProperty property : extension.properties()) {</span>
<span class="pc bpc" id="L559" title="1 of 4 branches missed.">                if (!property.name().isEmpty() &amp;&amp; !property.value().isEmpty()) {</span>

<span class="fc" id="L561">                    String propertyName = property.name();</span>
<span class="pc bpc" id="L562" title="1 of 4 branches missed.">                    if (name.isEmpty() &amp;&amp; !propertyName.startsWith(&quot;x-&quot;)) {</span>
<span class="fc" id="L563">                        propertyName = &quot;x-&quot; + propertyName;</span>
                    }

<span class="fc" id="L566">                    map.put(propertyName, property.value());</span>
                }
            }
        }
<span class="fc" id="L570">    }</span>

    protected Class&lt;?&gt; getSubResource(Method method) {
<span class="fc" id="L573">        final Class&lt;?&gt; rawType = method.getReturnType();</span>
        final Class&lt;?&gt; type;
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (Class.class.equals(rawType)) {</span>
<span class="fc" id="L576">            type = getClassArgument(method.getGenericReturnType());</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (type == null) {</span>
<span class="fc" id="L578">                return null;</span>
            }
        } else {
<span class="fc" id="L581">            type = rawType;</span>
        }
<span class="fc bfc" id="L583" title="All 2 branches covered.">        return type.getAnnotation(Api.class) != null ? type : null;</span>
    }

    private static Class&lt;?&gt; getClassArgument(Type cls) {
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">        if (cls instanceof ParameterizedType) {</span>
<span class="fc" id="L588">            final ParameterizedType parameterized = (ParameterizedType) cls;</span>
<span class="fc" id="L589">            final Type[] args = parameterized.getActualTypeArguments();</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">            if (args.length != 1) {</span>
<span class="nc" id="L591">                LOGGER.error(String.format(&quot;Unexpected class definition: %s&quot;, cls));</span>
<span class="nc" id="L592">                return null;</span>
            }
<span class="fc" id="L594">            final Type first = args[0];</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">            if (first instanceof Class) {</span>
<span class="fc" id="L596">                return (Class&lt;?&gt;) first;</span>
            } else {
<span class="fc" id="L598">                return null;</span>
            }
        } else {
<span class="nc" id="L601">            LOGGER.error(String.format(&quot;Unknown class definition: %s&quot;, cls));</span>
<span class="nc" id="L602">            return null;</span>
        }
    }

    protected Set&lt;String&gt; extractTags(Api api) {
<span class="fc" id="L607">        Set&lt;String&gt; output = new LinkedHashSet&lt;String&gt;();</span>

<span class="fc" id="L609">        boolean hasExplicitTags = false;</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">        for (String tag : api.tags()) {</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">            if (!&quot;&quot;.equals(tag)) {</span>
<span class="fc" id="L612">                hasExplicitTags = true;</span>
<span class="fc" id="L613">                output.add(tag);</span>
            }
        }
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (!hasExplicitTags) {</span>
            // derive tag from api path + description
<span class="fc" id="L618">            String tagString = api.value().replace(&quot;/&quot;, &quot;&quot;);</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            if (!&quot;&quot;.equals(tagString)) {</span>
<span class="fc" id="L620">                output.add(tagString);</span>
            }
        }
<span class="fc" id="L623">        return output;</span>
    }

    String getPath(javax.ws.rs.Path classLevelPath, javax.ws.rs.Path methodLevelPath, String parentPath) {
<span class="fc bfc" id="L627" title="All 6 branches covered.">        if (classLevelPath == null &amp;&amp; methodLevelPath == null &amp;&amp; StringUtils.isEmpty(parentPath)) {</span>
<span class="fc" id="L628">            return null;</span>
        }
<span class="fc" id="L630">        StringBuilder b = new StringBuilder();</span>
<span class="pc bpc" id="L631" title="2 of 6 branches missed.">        if (parentPath != null &amp;&amp; !&quot;&quot;.equals(parentPath) &amp;&amp; !&quot;/&quot;.equals(parentPath)) {</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">            if (!parentPath.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L633">                parentPath = &quot;/&quot; + parentPath;</span>
            }
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">            if (parentPath.endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L636">                parentPath = parentPath.substring(0, parentPath.length() - 1);</span>
            }

<span class="fc" id="L639">            b.append(parentPath);</span>
        }
<span class="fc bfc" id="L641" title="All 2 branches covered.">        if (classLevelPath != null) {</span>
<span class="fc" id="L642">            b.append(classLevelPath.value());</span>
        }
<span class="pc bpc" id="L644" title="1 of 4 branches missed.">        if (methodLevelPath != null &amp;&amp; !&quot;/&quot;.equals(methodLevelPath.value())) {</span>
<span class="fc" id="L645">            String methodPath = methodLevelPath.value();</span>
<span class="pc bpc" id="L646" title="1 of 4 branches missed.">            if (!methodPath.startsWith(&quot;/&quot;) &amp;&amp; !b.toString().endsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L647">                b.append(&quot;/&quot;);</span>
            }
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">            if (methodPath.endsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L650">                methodPath = methodPath.substring(0, methodPath.length() - 1);</span>
            }
<span class="fc" id="L652">            b.append(methodPath);</span>
        }
<span class="fc" id="L654">        String output = b.toString();</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">        if (!output.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L656">            output = &quot;/&quot; + output;</span>
        }
<span class="pc bpc" id="L658" title="1 of 4 branches missed.">        if (output.endsWith(&quot;/&quot;) &amp;&amp; output.length() &gt; 1) {</span>
<span class="fc" id="L659">            return output.substring(0, output.length() - 1);</span>
        } else {
<span class="fc" id="L661">            return output;</span>
        }
    }

    private Map&lt;String, Property&gt; parseResponseHeaders(ResponseHeader[] headers) {
<span class="fc" id="L666">        Map&lt;String, Property&gt; responseHeaders = null;</span>
<span class="pc bpc" id="L667" title="2 of 4 branches missed.">        if (headers != null &amp;&amp; headers.length &gt; 0) {</span>
<span class="fc bfc" id="L668" title="All 2 branches covered.">            for (ResponseHeader header : headers) {</span>
<span class="fc" id="L669">                String name = header.name();</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">                if (!&quot;&quot;.equals(name)) {</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                    if (responseHeaders == null) {</span>
<span class="fc" id="L672">                        responseHeaders = new HashMap&lt;String, Property&gt;();</span>
                    }
<span class="fc" id="L674">                    String description = header.description();</span>
<span class="fc" id="L675">                    Class&lt;?&gt; cls = header.response();</span>

<span class="pc bpc" id="L677" title="1 of 2 branches missed.">                    if (!isVoid(cls)) {</span>
<span class="fc" id="L678">                        final Property property = ModelConverters.getInstance().readAsProperty(cls);</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">                        if (property != null) {</span>
<span class="fc" id="L680">                            Property responseProperty = ContainerWrapper.wrapContainer(header.responseContainer(), property,</span>
                                    ContainerWrapper.ARRAY, ContainerWrapper.LIST, ContainerWrapper.SET);
<span class="fc" id="L682">                            responseProperty.setDescription(description);</span>
<span class="fc" id="L683">                            responseHeaders.put(name, responseProperty);</span>
<span class="fc" id="L684">                            appendModels(cls);</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L690">        return responseHeaders;</span>
    }

    public Operation parseMethod(Method method) {
<span class="fc" id="L694">        return parseMethod(method, Collections.&lt;Parameter&gt;emptyList());</span>
    }

    private Operation parseMethod(Method method, List&lt;Parameter&gt; globalParameters) {
<span class="fc" id="L698">        Operation operation = new Operation();</span>

<span class="fc" id="L700">        ApiOperation apiOperation = getAnnotation(method, ApiOperation.class);</span>
<span class="fc" id="L701">        ApiResponses responseAnnotation = getAnnotation(method, ApiResponses.class);</span>

<span class="fc" id="L703">        String operationId = method.getName();</span>
<span class="fc" id="L704">        String responseContainer = null;</span>

<span class="fc" id="L706">        Type responseType = null;</span>
<span class="fc" id="L707">        Map&lt;String, Property&gt; defaultResponseHeaders = new HashMap&lt;String, Property&gt;();</span>

<span class="fc bfc" id="L709" title="All 2 branches covered.">        if (apiOperation != null) {</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">            if (apiOperation.hidden()) {</span>
<span class="fc" id="L711">                return null;</span>
            }
<span class="pc bpc" id="L713" title="1 of 2 branches missed.">            if (!&quot;&quot;.equals(apiOperation.nickname())) {</span>
<span class="nc" id="L714">                operationId = method.getName();</span>
            }

<span class="fc" id="L717">            defaultResponseHeaders = parseResponseHeaders(apiOperation.responseHeaders());</span>

<span class="fc" id="L719">            operation</span>
                    .summary(apiOperation.value())
                    .description(apiOperation.notes());

<span class="pc bpc" id="L723" title="1 of 4 branches missed.">            if (apiOperation.response() != null &amp;&amp; !isVoid(apiOperation.response())) {</span>
<span class="fc" id="L724">                responseType = apiOperation.response();</span>
            }
<span class="fc bfc" id="L726" title="All 2 branches covered.">            if (!&quot;&quot;.equals(apiOperation.responseContainer())) {</span>
<span class="fc" id="L727">                responseContainer = apiOperation.responseContainer();</span>
            }
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">            if (apiOperation.authorizations() != null) {</span>
<span class="fc" id="L730">                List&lt;SecurityRequirement&gt; securities = new ArrayList&lt;SecurityRequirement&gt;();</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                for (Authorization auth : apiOperation.authorizations()) {</span>
<span class="pc bpc" id="L732" title="1 of 4 branches missed.">                    if (auth.value() != null &amp;&amp; !&quot;&quot;.equals(auth.value())) {</span>
<span class="fc" id="L733">                        SecurityRequirement security = new SecurityRequirement();</span>
<span class="fc" id="L734">                        security.setName(auth.value());</span>
<span class="fc" id="L735">                        AuthorizationScope[] scopes = auth.scopes();</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">                        for (AuthorizationScope scope : scopes) {</span>
<span class="pc bpc" id="L737" title="2 of 4 branches missed.">                            if (scope.scope() != null &amp;&amp; !&quot;&quot;.equals(scope.scope())) {</span>
<span class="nc" id="L738">                                security.addScope(scope.scope());</span>
                            }
                        }
<span class="fc" id="L741">                        securities.add(security);</span>
                    }
                }
<span class="fc bfc" id="L744" title="All 2 branches covered.">                if (securities.size() &gt; 0) {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">                    for (SecurityRequirement sec : securities) {</span>
<span class="fc" id="L746">                        operation.security(sec);</span>
<span class="fc" id="L747">                    }</span>
                }
            }
<span class="pc bpc" id="L750" title="1 of 4 branches missed.">            if (apiOperation.consumes() != null &amp;&amp; !apiOperation.consumes().isEmpty()) {</span>
<span class="fc" id="L751">                operation.consumes(apiOperation.consumes());</span>
            }
<span class="pc bpc" id="L753" title="1 of 4 branches missed.">            if (apiOperation.produces() != null &amp;&amp; !apiOperation.produces().isEmpty()) {</span>
<span class="fc" id="L754">                operation.produces(apiOperation.produces());</span>
            }
        }

<span class="fc bfc" id="L758" title="All 4 branches covered.">        if (apiOperation != null &amp;&amp; StringUtils.isNotEmpty(apiOperation.responseReference())) {</span>
<span class="fc" id="L759">            Response response = new Response().description(SUCCESSFUL_OPERATION);</span>
<span class="fc" id="L760">            response.schema(new RefProperty(apiOperation.responseReference()));</span>
<span class="fc" id="L761">            operation.addResponse(String.valueOf(apiOperation.code()), response);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">        } else if (responseType == null) {</span>
            // pick out response from method declaration
<span class="fc" id="L764">            LOGGER.debug(&quot;picking up response class from method &quot; + method);</span>
<span class="fc" id="L765">            responseType = method.getGenericReturnType();</span>
        }
<span class="fc bfc" id="L767" title="All 2 branches covered.">        if (isValidResponse(responseType)) {</span>
<span class="fc" id="L768">            final Property property = ModelConverters.getInstance().readAsProperty(responseType);</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">            if (property != null) {</span>
<span class="fc" id="L770">                final Property responseProperty = ContainerWrapper.wrapContainer(responseContainer, property);</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">                final int responseCode = apiOperation == null ? 200 : apiOperation.code();</span>
<span class="fc" id="L772">                operation.response(responseCode, new Response().description(SUCCESSFUL_OPERATION).schema(responseProperty)</span>
                        .headers(defaultResponseHeaders));
<span class="fc" id="L774">                appendModels(responseType);</span>
            }
        }

<span class="fc" id="L778">        operation.operationId(operationId);</span>

        Annotation annotation;
<span class="pc bpc" id="L781" title="1 of 6 branches missed.">        if (apiOperation != null &amp;&amp; apiOperation.consumes() != null &amp;&amp; apiOperation.consumes().isEmpty()) {</span>
<span class="fc" id="L782">            annotation = getAnnotation(method, Consumes.class);</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">            if (annotation != null) {</span>
<span class="fc" id="L784">                String[] apiConsumes = ((Consumes) annotation).value();</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">                for (String mediaType : apiConsumes) {</span>
<span class="fc" id="L786">                    operation.consumes(mediaType);</span>
                }
            }
        }

<span class="pc bpc" id="L791" title="1 of 6 branches missed.">        if (apiOperation != null &amp;&amp; apiOperation.produces() != null &amp;&amp; apiOperation.produces().isEmpty()) {</span>
<span class="fc" id="L792">            annotation = getAnnotation(method, Produces.class);</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">            if (annotation != null) {</span>
<span class="fc" id="L794">                String[] apiProduces = ((Produces) annotation).value();</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">                for (String mediaType : apiProduces) {</span>
<span class="fc" id="L796">                    operation.produces(mediaType);</span>
                }
            }
        }

<span class="fc" id="L801">        List&lt;ApiResponse&gt; apiResponses = new ArrayList&lt;ApiResponse&gt;();</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">        if (responseAnnotation != null) {</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">            for (ApiResponse apiResponse : responseAnnotation.value()) {</span>
<span class="fc" id="L804">                Map&lt;String, Property&gt; responseHeaders = parseResponseHeaders(apiResponse.responseHeaders());</span>

<span class="fc" id="L806">                Response response = new Response()</span>
                        .description(apiResponse.message())
                        .headers(responseHeaders);

<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                if (apiResponse.code() == 0) {</span>
<span class="nc" id="L811">                    operation.defaultResponse(response);</span>
                } else {
<span class="fc" id="L813">                    operation.response(apiResponse.code(), response);</span>
                }

<span class="fc bfc" id="L816" title="All 2 branches covered.">                if (StringUtils.isNotEmpty(apiResponse.reference())) {</span>
<span class="fc" id="L817">                    response.schema(new RefProperty(apiResponse.reference()));</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">                } else if (!isVoid(apiResponse.response())) {</span>
<span class="fc" id="L819">                    responseType = apiResponse.response();</span>
<span class="fc" id="L820">                    final Property property = ModelConverters.getInstance().readAsProperty(responseType);</span>
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">                    if (property != null) {</span>
<span class="fc" id="L822">                        response.schema(ContainerWrapper.wrapContainer(apiResponse.responseContainer(), property));</span>
<span class="fc" id="L823">                        appendModels(responseType);</span>
                    }
                }
            }
        }
<span class="fc" id="L828">        boolean isDeprecated = false;</span>
<span class="fc" id="L829">        annotation = method.getAnnotation(Deprecated.class);</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">        if (annotation != null) {</span>
<span class="nc" id="L831">            isDeprecated = true;</span>
        }

<span class="fc" id="L834">        boolean hidden = false;</span>
<span class="fc bfc" id="L835" title="All 2 branches covered.">        if (apiOperation != null) {</span>
<span class="fc" id="L836">            hidden = apiOperation.hidden();</span>
        }

        // process parameters
<span class="fc bfc" id="L840" title="All 2 branches covered.">        for (Parameter globalParameter : globalParameters) {</span>
<span class="fc" id="L841">            operation.parameter(globalParameter);</span>
<span class="fc" id="L842">        }</span>

<span class="fc" id="L844">        Type[] genericParameterTypes = method.getGenericParameterTypes();</span>
<span class="fc" id="L845">        Annotation[][] paramAnnotations = method.getParameterAnnotations();</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">        for (int i = 0; i &lt; genericParameterTypes.length; i++) {</span>
<span class="fc" id="L847">            Type type = genericParameterTypes[i];</span>
<span class="fc" id="L848">            List&lt;Parameter&gt; parameters = getParameters(type, Arrays.asList(paramAnnotations[i]));</span>

<span class="fc bfc" id="L850" title="All 2 branches covered.">            for (Parameter parameter : parameters) {</span>
<span class="fc" id="L851">                operation.parameter(parameter);</span>
<span class="fc" id="L852">            }</span>
        }

<span class="fc bfc" id="L855" title="All 2 branches covered.">        if (operation.getResponses() == null) {</span>
<span class="fc" id="L856">            Response response = new Response().description(SUCCESSFUL_OPERATION);</span>
<span class="fc" id="L857">            operation.defaultResponse(response);</span>
        }
<span class="fc" id="L859">        return operation;</span>
    }

    private static &lt;A extends Annotation&gt; A getAnnotation(Method method, Class&lt;A&gt; annotationClass) {
<span class="fc" id="L863">        A annotation = method.getAnnotation(annotationClass);</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">        if (annotation == null) {</span>
<span class="fc" id="L865">            Method superclassMethod = ReflectionUtils.getOverriddenMethod(method);</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">            if (superclassMethod != null) {</span>
<span class="fc" id="L867">                annotation = getAnnotation(superclassMethod, annotationClass);</span>
            }
        }
<span class="fc" id="L870">        return annotation;</span>
    }

    private List&lt;Parameter&gt; getParameters(Type type, List&lt;Annotation&gt; annotations) {
<span class="fc" id="L874">        final Iterator&lt;SwaggerExtension&gt; chain = SwaggerExtensions.chain();</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">        if (!chain.hasNext()) {</span>
<span class="nc" id="L876">            return Collections.emptyList();</span>
        }
<span class="fc" id="L878">        LOGGER.debug(&quot;getParameters for &quot; + type);</span>
<span class="fc" id="L879">        Set&lt;Type&gt; typesToSkip = new HashSet&lt;Type&gt;();</span>
<span class="fc" id="L880">        final SwaggerExtension extension = chain.next();</span>
<span class="fc" id="L881">        LOGGER.debug(&quot;trying extension &quot; + extension);</span>

<span class="fc" id="L883">        final List&lt;Parameter&gt; parameters = extension.extractParameters(annotations, type, typesToSkip, chain);</span>

<span class="fc bfc" id="L885" title="All 2 branches covered.">        if (parameters.size() &gt; 0) {</span>
<span class="fc" id="L886">            final List&lt;Parameter&gt; processed = new ArrayList&lt;Parameter&gt;(parameters.size());</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">            for (Parameter parameter : parameters) {</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">                if (ParameterProcessor.applyAnnotations(swagger, parameter, type, annotations) != null) {</span>
<span class="fc" id="L889">                    processed.add(parameter);</span>
                }
<span class="fc" id="L891">            }</span>
<span class="fc" id="L892">            return processed;</span>
        } else {
<span class="fc" id="L894">            LOGGER.debug(&quot;no parameter found, looking at body params&quot;);</span>
<span class="fc" id="L895">            final List&lt;Parameter&gt; body = new ArrayList&lt;Parameter&gt;();</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">            if (!typesToSkip.contains(type)) {</span>
<span class="fc" id="L897">                Parameter param = ParameterProcessor.applyAnnotations(swagger, null, type, annotations);</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">                if (param != null) {</span>
<span class="fc" id="L899">                    body.add(param);</span>
                }
            }
<span class="fc" id="L902">            return body;</span>
        }
    }

    public String extractOperationMethod(ApiOperation apiOperation, Method method, Iterator&lt;SwaggerExtension&gt; chain) {
<span class="pc bpc" id="L907" title="1 of 6 branches missed.">        if (apiOperation != null &amp;&amp; apiOperation.httpMethod() != null &amp;&amp; !&quot;&quot;.equals(apiOperation.httpMethod())) {</span>
<span class="fc" id="L908">            return apiOperation.httpMethod().toLowerCase();</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">        } else if (method.getAnnotation(javax.ws.rs.GET.class) != null) {</span>
<span class="fc" id="L910">            return &quot;get&quot;;</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">        } else if (method.getAnnotation(javax.ws.rs.PUT.class) != null) {</span>
<span class="fc" id="L912">            return &quot;put&quot;;</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">        } else if (method.getAnnotation(javax.ws.rs.POST.class) != null) {</span>
<span class="fc" id="L914">            return &quot;post&quot;;</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">        } else if (method.getAnnotation(javax.ws.rs.DELETE.class) != null) {</span>
<span class="fc" id="L916">            return &quot;delete&quot;;</span>
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">        } else if (method.getAnnotation(javax.ws.rs.OPTIONS.class) != null) {</span>
<span class="nc" id="L918">            return &quot;options&quot;;</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">        } else if (method.getAnnotation(javax.ws.rs.HEAD.class) != null) {</span>
<span class="nc" id="L920">            return &quot;head&quot;;</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">        } else if (method.getAnnotation(PATCH.class) != null) {</span>
<span class="nc" id="L922">            return &quot;patch&quot;;</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">        } else if (method.getAnnotation(HttpMethod.class) != null) {</span>
<span class="nc" id="L924">            HttpMethod httpMethod = (HttpMethod) method.getAnnotation(HttpMethod.class);</span>
<span class="nc" id="L925">            return httpMethod.value().toLowerCase();</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">        } else if ((ReflectionUtils.getOverriddenMethod(method)) != null) {</span>
<span class="fc" id="L927">            return extractOperationMethod(apiOperation, ReflectionUtils.getOverriddenMethod(method), chain);</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        } else if (chain.hasNext()) {</span>
<span class="fc" id="L929">            return chain.next().extractOperationMethod(apiOperation, method, chain);</span>
        } else {
<span class="nc" id="L931">            return null;</span>
        }
    }



    private static Set&lt;Scheme&gt; parseSchemes(String schemes) {
<span class="fc" id="L938">        final Set&lt;Scheme&gt; result = EnumSet.noneOf(Scheme.class);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">        for (String item : StringUtils.trimToEmpty(schemes).split(&quot;,&quot;)) {</span>
<span class="fc" id="L940">            final Scheme scheme = Scheme.forValue(StringUtils.trimToNull(item));</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">            if (scheme != null) {</span>
<span class="fc" id="L942">                result.add(scheme);</span>
            }
        }
<span class="fc" id="L945">        return result;</span>
    }

    private void appendModels(Type type) {
<span class="fc" id="L949">        final Map&lt;String, Model&gt; models = ModelConverters.getInstance().readAll(type);</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">        for (Map.Entry&lt;String, Model&gt; entry : models.entrySet()) {</span>
<span class="fc" id="L951">            swagger.model(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L952">        }</span>
<span class="fc" id="L953">    }    private static boolean isVoid(Type type) {</span>
<span class="fc" id="L954">        final Class&lt;?&gt; cls = TypeFactory.defaultInstance().constructType(type).getRawClass();</span>
<span class="fc bfc" id="L955" title="All 4 branches covered.">        return Void.class.isAssignableFrom(cls) || Void.TYPE.isAssignableFrom(cls);</span>
    }

    private boolean isIgnored(String path) {
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">        for (String item : config.getIgnoredRoutes()) {</span>
<span class="nc" id="L960">            final int length = item.length();</span>
<span class="nc bnc" id="L961" title="All 6 branches missed.">            if (path.startsWith(item) &amp;&amp; (path.length() == length || path.startsWith(PATH_DELIMITER, length))) {</span>
<span class="nc" id="L962">                return true;</span>
            }
<span class="nc" id="L964">        }</span>
<span class="fc" id="L965">        return false;</span>
    }    private static boolean isValidResponse(Type type) {
<span class="fc bfc" id="L967" title="All 2 branches covered.">        if (type == null) {</span>
<span class="fc" id="L968">            return false;</span>
        }
<span class="fc" id="L970">        final JavaType javaType = TypeFactory.defaultInstance().constructType(type);</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">        if (isVoid(javaType)) {</span>
<span class="fc" id="L972">            return false;</span>
        }
<span class="fc" id="L974">        final Class&lt;?&gt; cls = javaType.getRawClass();</span>
<span class="fc bfc" id="L975" title="All 4 branches covered.">        return !javax.ws.rs.core.Response.class.isAssignableFrom(cls) &amp;&amp; !isResourceClass(cls);</span>
    }

    private List&lt;Parameter&gt; collectGlobalParameters(Class&lt;?&gt; cls) {
<span class="fc" id="L979">        final List&lt;Parameter&gt; globalParameters = new ArrayList&lt;Parameter&gt;();</span>

        // look for constructor-level annotated properties
<span class="fc" id="L982">        final Constructor&lt;?&gt; constructor = ReflectionUtils.findConstructor(cls);</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">        if (constructor != null) {</span>
<span class="fc" id="L984">            final Type[] genericParameterTypes = constructor.getGenericParameterTypes();</span>
<span class="fc" id="L985">            final Annotation[][] annotations = constructor.getParameterAnnotations();</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">            for (int i = 0; i &lt; genericParameterTypes.length; i++) {</span>
<span class="fc" id="L987">                globalParameters.addAll(getParameters(genericParameterTypes[i], Arrays.asList(annotations[i])));</span>
            }
        }

        // look for field-level annotated properties
<span class="fc bfc" id="L992" title="All 2 branches covered.">        for (Field field : cls.getDeclaredFields()) {</span>
<span class="fc" id="L993">            final List&lt;Annotation&gt; annotations = Arrays.asList(field.getAnnotations());</span>
<span class="fc" id="L994">            final Collection&lt;Class&lt;? extends Annotation&gt;&gt; types = Collections2.transform(annotations, ReflectionUtils.createAnnotationTypeGetter());</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">            if (!Collections.disjoint(types, FIELD_ANNOTATIONS)) {</span>
<span class="fc" id="L996">                globalParameters.addAll(getParameters(field.getGenericType(), annotations));</span>
            }
        }

<span class="fc" id="L1000">        return globalParameters;</span>
    }    private static boolean isResourceClass(Class&lt;?&gt; cls) {
<span class="fc bfc" id="L1002" title="All 2 branches covered.">        return cls.getAnnotation(Api.class) != null;</span>
    }

    public ReaderConfig getConfig() {
<span class="nc" id="L1006">        return config;</span>
    }

<span class="pc" id="L1009">    enum ContainerWrapper {</span>
<span class="fc" id="L1010">        LIST(&quot;list&quot;) {</span>
            @Override
            protected Property doWrap(Property property) {
<span class="fc" id="L1013">                return new ArrayProperty(property);</span>
            }
        },
<span class="fc" id="L1016">        ARRAY(&quot;array&quot;) {</span>
            @Override
            protected Property doWrap(Property property) {
<span class="fc" id="L1019">                return new ArrayProperty(property);</span>
            }
        },
<span class="fc" id="L1022">        MAP(&quot;map&quot;) {</span>
            @Override
            protected Property doWrap(Property property) {
<span class="fc" id="L1025">                return new MapProperty(property);</span>
            }
        },
<span class="fc" id="L1028">        SET(&quot;set&quot;) {</span>
            @Override
            protected Property doWrap(Property property) {
<span class="fc" id="L1031">                ArrayProperty arrayProperty = new ArrayProperty(property);</span>
<span class="fc" id="L1032">                arrayProperty.setUniqueItems(true);</span>
<span class="fc" id="L1033">                return arrayProperty;</span>
            }
        };

        private final String container;

<span class="fc" id="L1039">        ContainerWrapper(String container) {</span>
<span class="fc" id="L1040">            this.container = container;</span>
<span class="fc" id="L1041">        }</span>

        public static Property wrapContainer(String container, Property property, ContainerWrapper... allowed) {
<span class="fc bfc" id="L1044" title="All 2 branches covered.">            final Set&lt;ContainerWrapper&gt; tmp = allowed.length &gt; 0 ? EnumSet.copyOf(Arrays.asList(allowed)) : EnumSet.allOf(ContainerWrapper.class);</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">            for (ContainerWrapper wrapper : tmp) {</span>
<span class="fc" id="L1046">                final Property prop = wrapper.wrap(container, property);</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">                if (prop != null) {</span>
<span class="fc" id="L1048">                    return prop;</span>
                }
<span class="fc" id="L1050">            }</span>
<span class="fc" id="L1051">            return property;</span>
        }

        public Property wrap(String container, Property property) {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (this.container.equalsIgnoreCase(container)) {</span>
<span class="fc" id="L1056">                return doWrap(property);</span>
            }
<span class="fc" id="L1058">            return null;</span>
        }

        protected abstract Property doWrap(Property property);
    }

    static {
<span class="fc" id="L1065">        final Set&lt;Class&lt;? extends Annotation&gt;&gt; fieldAnnotations = new HashSet&lt;Class&lt;? extends Annotation&gt;&gt;();</span>
<span class="fc" id="L1066">        fieldAnnotations.add(PathParam.class);</span>
<span class="fc" id="L1067">        fieldAnnotations.add(QueryParam.class);</span>
<span class="fc" id="L1068">        fieldAnnotations.add(HeaderParam.class);</span>
<span class="fc" id="L1069">        fieldAnnotations.add(ApiParam.class);</span>
<span class="fc" id="L1070">        fieldAnnotations.add(ApiImplicitParam.class);</span>
<span class="fc" id="L1071">        FIELD_ANNOTATIONS = Collections.unmodifiableSet(fieldAnnotations);</span>
<span class="fc" id="L1072">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>